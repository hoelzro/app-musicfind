#!/usr/bin/perl

use strict;
use warnings;

use File::Find;

use constant DEBUG => 1;

BEGIN
{
    if(DEBUG) {
        require Data::Dumper;
        Data::Dumper->import();
    }
}

=pod
Documentation:
Convert that under __END__ into POD

Finishing touches:
Reload file data after rename (and exec?)
Make sure that filters are separated by -and or -or (implicit)
Uncomment loadDecoders and find
Make -exec into a filter?
Try to break up processCmdLine a bit
As usual, look for comments

How 'bout writing those plugins?
=cut


my @decoders;
my @targets; # Dirs to search
my @actions; # What to do for each file

sub glob_to_regex_string
{
    my $glob = shift;

    $glob =~ s/\*/.*/g;
    $glob =~ s/\?/./g;

    return $glob;
}

sub loadDecoders
{
    my $decoderDir;
    foreach my $inc (@INC) {
        if(-d "$inc/MusicFind") {
            $decoderDir = "$inc/MusicFind";
            last;
        }
    }
    if($decoderDir) {
        opendir my $handle, $decoderDir or die "Unable to open $decoderDir: $!\n";
        my @modules = readdir $handle;
        @modules = grep { /^[^.]/ && /\.pm$/ } @modules;
        closedir $handle;
        foreach my $module (@modules) {
            eval {
                require "MusicFind/$module";
            };
            # Print warning if a decoder failed to load?
            push @decoders, "MusicFind/$module" unless($@);
        }
    }
    unless(@decoders) {
        die "Unable to load any decoding modules;  you should probably try to reinstall musicfind.\n";
    }
}

sub processCmdLine
{
    my $lastAction = '';
    my %filterActions = ('-channels' => 1, '-tag' => 1, ')' => 1, '(' => 1);
    my @filters;
    my $i;
    my $parenLevel = 0;
    my $ignoreCase = '';

    # Dispatch table
    my %dispatch = (
        '-and' => sub {
            if(exists $filterActions{$lastAction} && exists $filterActions{$_[$i + 1]}) {
                push @filters, ['and'];
            } else {
                die "Only filter actions can occur on either side of an -and switch\n";
            }
        },
        '-or' => sub {
            if(exists $filterActions{$lastAction} && exists $filterActions{$_[$i + 1]}) {
                push @filters, ['or'];
            } else {
                die "Only filter actions can occur on either side of an -or switch\n";
            }
        },
        '-not' => sub {
            if(exists $filterActions{$_[$i + 1]}) {
                push @filters, ['not'];
            } else {
                die "Only filter actions can occur after a -not switch\n";
            }
        },
        '-rename' => sub {
            if($parenLevel) {
                die "Only filters may occur within parentheses\n";
            }
            push @actions, ['rename', $_[++$i]];
        },
        '-tag' => sub {
            my @tags = split /,/, $_[++$i];

            my $action = ['check_tag'];
            foreach my $tag (@tags) {
                if($tag =~ /(.+)=(.+)/) {
                    my ($name, $value) = ($1, $2);
                    if($value =~ /^\/(.*)\/(i)?$/) {
                        my $ignore = $2 ? '(?i)' : '';
                        $value = "${ignore}$1";
                        eval {
                            qr/$value/;
                        };
                        if($@) {
                            die "Invalid regular expression input: /$1/\n";
                        }
                    } else {
                        $value = glob_to_regex_string($value);
                    }
                    push @$action, $name, $value;
                } else {
                    die "Tag matches must be in the format name=value; $tag is invalid\n";
                }
            }
            push @filters, $action;
        },
        '-set-tag' => sub {
            if($parenLevel) {
                die "Only filters may occur within parentheses\n";
            }
            my @tags = split /,/, $_[++$i];

            my $action = ['set_tag'];
            foreach my $tag (@tags) {
                if($tag =~ /(.+)=(.+)/) {
                    my ($name, $value) = ($1, $2);
                    push @$action, $name, $value;
                } else {
                    die "Tag matches must be in the format name=value; $tag is invalid\n";
                }
            }
            push @actions, $action;
        },
        '-delete-tag' => sub {
            if($parenLevel) {
                die "Only filters may occur within parentheses\n";
            }
            my @tags = split /,/, $_[++$i];
            push @actions, ['delete_tag', @tags];
        },
        '-channels' => sub {
            my $num = $_[++$i];
            if($num =~ /^\d+$/) {
                push @filters, ['channels', $num];
            } else {
                die "You didn't specify an integer for the number of channels\n";
            }
        },
        '-print' => sub {
            if($parenLevel) {
                die "Only filters may occur within parentheses\n";
            }
            if(! defined $_[$i + 1] || $_[$i + 1] =~ /^-/ || $_[$i + 1] =~ /^\(|\)$/) {
                push @actions, ['print'];
            } else {
                push @actions, ['print', $_[++$i]];
            }
        },
        '-help' => sub {
            print while(<DATA>);
            exit(0);
        },
        '(' => sub {
            push @filters, ['('];
            $parenLevel++;
        },
        ')' => sub {
            push @filters, [')'];
            unless($parenLevel) {
                die "Unmatching parentheses\n";
            }
            $parenLevel--;
        },
        '-exec' => sub {
            my @args;
            $i++;
            push @args, $_[$i++] until($i >= @_ || $_[$i] eq ';');
            die "-exec is missing a terminating semicolon\n" unless(defined $_[$i]);
            push @actions, ['exec', @args];
        },
        '-ignore-case' => sub {
            $ignoreCase = 'i';
        },
        '--' => sub {
            push @targets, @_[$i + 1 .. @_ - 1];
            $i = @_;
        }
    );

    # Processes targets
    while(@_ && $_[0] !~ /^-/ && $_[0] !~ /^\(|\)$/) {
        push @targets, split(/,/, $_[0]);
        shift;
    }

    # Processes remainder of arguments
    for($i = 0; $i < @_; $i++) {
        my $arg = $_[$i];
        if(exists $dispatch{$arg}) {
            $dispatch{$arg}->(@_);
        } else {
            die "Invalid argument: $arg.  Try -help.\n";
        }
        $lastAction = $arg;
    }

    # Check that all parens are matched
    if($parenLevel) {
        die "Unmatching parentheses\n";
    }

    # Verify that there are targets
    unless(@targets) {
        die "No target directories were provided; try -help for options\n";
    }

    # If no actions are specified, default to print
    unless(@actions) {
        push @actions, ['print'];
    }

    # Create the filter subroutine dynamically
    foreach my $filter (@filters) {
        if(@$filter[0] eq 'and') {
            $filter = '&&';
        } elsif(@$filter[0] eq 'or') {
            $filter = '||';
        } elsif(@$filter[0] eq 'not') {
            $filter = '!';
        } elsif(@$filter[0] eq 'channels') {
            $filter = "\$file->channels == @$filter[1]";
        } elsif(@$filter[0] eq 'check_tag') {
            my @tags;
            for(my $i = 1; $i < @$filter; $i += 2) {
                my ($name, $value) = (@$filter[$i], @$filter[$i + 1]);
                push @tags, "\$file->tag(\'$name\') =~ /$value/o$ignoreCase";
            }
            $filter = join ' && ', @tags;
        } elsif(@$filter[0] eq '(') {
            $filter = '(';
        } elsif(@$filter[0] eq ')') {
            $filter = ')';
        }
    }
    my $filterConditions;
    if(@filters) {
        $filterConditions = join ' ', @filters;
    } else {
        $filterConditions = 1;
    }
    eval <<PERL;
    sub applyFilters {
        my \$file = shift;
        return $filterConditions;
    }
PERL
    if($@) {
        die "An eval error occured for condition string \"$filterConditions\": $!.\nPlease send this message along with the arguments you used to hoelz\@wisc.edu so the developer can fix the issue\n";
    }

    # Debugging stuff
    if(DEBUG) {
        local $\ = "\n";
        local $, = ' ';
        print "Actions: ", Dumper(\@actions);
        print "Targets: ", Dumper(\@targets);
        print "Filter string: $filterConditions";
        exit(0);
    }
}

sub loadMusicFile
{
    my $filename = shift;

    foreach my $dec (@decoders) {
        if($dec->accept($filename)) {
            return $dec->new($filename);
        }
    }
    return undef;
}

sub findRoutine
{
    my $file = loadMusicFile($_);
    if($file && applyFilters($file)) {
        foreach my $action (@actions) {
            my ($method, @args) = @$action;
            $file->$method(@args);
        }
    }
}

#loadDecoders;
processCmdLine(@ARGV);
#find(\&findRoutine, @targets);

__END__
musicfind [targets] [options]
musicfind is a utility similar to the Unix command line utility find, only
specialized for music files.  The targets are a list of files/directories to
search, and the options can be categorized into filters and actions:

Targets

The target files/directories are the arguments before the first - argument.
Each argument is also split by commas.  Also, all arguments following -- are
added to the target list, but these are NOT split by commas.  Examples:

musicfind . foo -print # Searches the current directory and directory foo
musicfind .,foo -print # Same thing
musicfind . -print -- foo # Same thing
musicfind . -print -- foo,bar -baz # Searches the current directory, directory
                                     foo,bar, and directory -baz

Filters

    -channels num Filters out files that do not have num channels.
    -tag name=value(,name=value)* Filters out files that don't match the given
                                  tag name-value pairs.  The value can be a
                                  regular string, a sh-style wildcard, or a
                                  Perl regular expression.  Regexes must start
                                  and end with /.

Although not techincally filters, these next three options allow the user to
better manipulate filters:

    -and Only selects files that the previous and next filters are both true
         for.
    -or  Only selects files that the previous or the next filters are true for.
    -not Only selects files that the next filter is not true for.

Actions

    -rename new_name Renames the file according to new_name, which is a
                     printf-style format string.  See below for details.
    -set-tag name=value(,name=value)* Sets the tags specified by the given names
                                      to the given values.
    -delete-tag name(,name)* Deletes the tags with the names specified.
    -print (format)? Prints the file name.  If format is specified, prints a
                     printf-style string.  Details below.
    -exec Functions similar to find's -exec.  All arguments up to ; are included
          arguments to the given program.
    -help Print this message and exit.

Rename/Print Format

The printf-style format string for rename and print is similar to printf;  The
only difference that instead of % fields specifying how to output a field, they
specify which tag to output.  %% still expands to %.

Examples

This one prints the filenames of all music files with the artist tagged as
System of a Down:

musicfind . -tag artist="System of a Down"

This one renames files to an artist - title format:

musicfind . -rename "%artist - %title"

This one purges your computer of evil:

musicfind / -tag artist="Britney Spears" -exec rm '{}' \;

Plugin Oriented Architecture

Musicfind doesn't have any intrinsic support built in for any particular music
file format;  all of the work specific to a file type is done by the
MusicFind::* modules.  Currently I've written plugins for Ogg Vorbis, MP3, and
Flac;  if you'd like to contribute, MusicFind.pm documents what methods a plugin
needs to implement and exactly what they're supposed to do.  Plugins should then
be placed into MusicFind/ under your @INC.

Case Sensitivity

For reasons I'd rather not explain, tag names in searches and other situations
are case-insensitive, but tag values are case-sensitive in searches.  This is
mainly because different tools tag an artist as Artist, artist, ARTIST, etc.  If
you want a case-insensitive value search, use the -ignore-case option:

musicfind . -tag artist="System of a Down" -ignore-case

-ignore-case works with either wildcards or regexes, and appending /i to the end
of a regex will do the same thing as -ignore-case, but only for that regex!

Bugs and Ideas

If you have found any bugs or have any great ideas for musicfind, please send
them to me (patches are nice!) at hoelz@wisc.edu.  I'll be making my darcs
repository for the project public soon, so I'll post that in here when I can.

Enjoy!
